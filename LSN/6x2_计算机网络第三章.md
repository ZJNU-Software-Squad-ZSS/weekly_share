# 第三章
### 传输服务和协议
用于不同主机应用进程间的逻辑通信
运行于网络边缘，发送端将应用消息分段，传递给网络层，接收端整合分段内容为消息，传递给应用层
两个协议:
TCP 可靠有序的交付
UDP 不可靠的无序的交付
### 多路复用/多路分解
多路复用：从socket汇集数据，使用一个头部封装在数据报中发出去
多路分解：接收一个数据报后，正确分发数据段给socket
##### 多路分解
一个数据报有
source IP address 源IP地址
destination IP address 目标IP地址
传输层segment{源端口号 目的端口号 其他参数 data}
主机使用IP地址和端口将segment转发给相应的socket
**UDP的分解**
检查目的IP地址是否正确，检查目的端口号，分发相应的socket
**TCP分解**
使用源IP地址、源端口号、目的IP地址、目的端口号四个字段区分不同的socket
### UDP
**特点**
无连接、不可靠、速度快
头部只有8bytes
只对IP进行了多路复用、多路分解、差错检测
不受拥塞算法控制
### 可信数据传输原理
两个部分：
应用程序调用接口交付数据~数据报通过不可信信道传输
数据到达接收端~数据交付给上层
##### 比特位错误
数据报在下层信道传输可能某些比特位翻转
**流程**
sender发送一个数据包，顺序号为0
receiver收到数据包，用校验和检测错误，没有错误返回ACK-0
sender收到ACK-0，发送下一个数据包，顺序号为1
receiver收到数据包，用校验和检测错误，发现错误返回ACK-0
sender收到ACK-0，知道上一个数据包发生错误，并重传
##### 数据包可能丢失
**流程**
sender发送一个数据包，顺序号为1
sender长时间未收到ACK，进行重传
如果数据包真的丢失了，则receiver正常收包
如果数据包只是因为长时间排队而导致了重复，则receiver需要通过顺序号丢掉重复数据包
##### 流水线协议
由于sender等待ACK会使传输变的十分低下
因此让sender在等待前面ACK的同时继续发送数据包
这些数据包使用缓冲区，为在途，等待确认的数据包（流水线）
这用到了流水线协议（两种
**Go-back-N**
发送者在流水线中最多有N个未确认数据包
若数据包a出错，接受者在收到a之后的数据包时都将返回ACK a-1
发送者接收到第一个ACK a-1时， 数据包a为最久未确认数据包，发送者对a进行计时
超时时，发送者已经发送到数据包b（此前收到的都是ACK a-1），发送者将重传[a,b]之间的所有数据包
**选择重传**
发送者在流水线中最多有N个未确认数据包
接受者对单个数据包进行确认
发送者对每个数据包计时，超时将重传该未确认数据包
接受者接收到未按顺序的数据包时将该包进行缓冲，等待发送者重传
### TCP
##### 段结构
源端口号，目的端口号 各16bit
序列号字段32bit
确认号字段32bit
偏移字段4bit 保留字段6bit URG ACK PSH RST SYN FIN各1bit  接受窗口字段16bit
包校验和16bit 紧急指针16bit
供20字节
1个Mss（最大报文长度）为20字节加上有效数据
**序列号和确认号**seq and ack
（三次握手部分）
SYN表示建立连接
ACK表示确认收到
```
    //客户端请求连接
　　客户端--SYN=1 ACK=0 seq=X-->服务端
　　//服务端响应该连接（通过序列号+1）
　　客户端<--SYN=1 ACK=1 seq=Y ack=X+1--服务端
　　//客户端确认服务器响应，（通过序列号+1
　　客户端--ACK=1 seq=X+1 ack=Y+1-->服务端
```
（传输数据部分），假设X=Y=0
```c++
    //开始传输有效数据，长度为725
　　客户端--PSH=1 ACK=1 seq=1 ack=1-->服务端
　　
　　//服务端上次未发送有效数据，这次收到了725长度
　　//确认号+725
　　客户端<--ACK=1 seq=1 ack=726--服务端
　　
　　//服务端开始返回数据，长度为1448
　　//服务端上次未发送有效数据，也未收到新数据
　　客户端<--ACK=1 seq=1 ack=726--服务端
　　
　　//客户端上次发送了725长度，这次收到了1448长度
　　//序列号+725，确认号+1448，响应给服务器
    客户端--ACK=1 seq=726 ack=1449-->服务端　　
    
    //服务端上次发送有效数据1448，未收到新数据
    //序列号+1448
    客户端<--ACK=1 seq=1449 ack=726--服务端
    
    //客户端上次未发送数据，这次收到了1448长度
　　//确认号+1448，响应给服务器
    客户端--ACK=1 seq=726 ack=2897-->服务端　　
```
（四次挥手部分）
FIN表示断开连接
客户端和服务端都可以是主动断开的一方
```
    //客户端主动断开，发送FIN，seq,ack和上次相同
    客户端--FIN=1 seq=726 ack=2897-->服务端
    //服务端被动关闭，2897是上次发送有效数据1448+序列号1449
    客户端<--ACK=1 seq=2897 ack=726+1--服务端
    //服务端发送FIN
    客户端<--FIN=1--服务端
    //客户端ACK
    客户端--ACK=1 seq=726+1 ack=2897-->服务端
```

4、发送数据时，服务器向客户端发送一个数据包，序列号和确认号与3相同
5、客户端收到数据时，发送一个确认数据包，序列号为上一个数据包中的确认号值，确认号为服务器发送的上一个数据包中序列号+该数据包的数据的大小
##### TCP的可信数据传输
**发送者**
封装带序列号的字段
设置定时器对最久未确认报文计时
超时时重传，重启定时器
收到新的ACK时更新数据、重启定时器
由于接收者在正常接收时其返回ACK是有序的，所以即使一个ACK丢失，发送者收到后面的ACK时也知道接收者正常接受了数据而不重传
**快速重传**
接收方收到错误/非有序的数据包时将发送重复的ACK（最后正确的）
发送方收到3个重复的ACK时将认定数据包丢失，重传ACK所指的下一个数据包，而不用等待超时
##### 流量控制
接收方应用程序读取socket缓存慢于发送方发送速度，将会使缓存被填满
**解决方法**
接收方会告诉发送方缓存空间的大小-接收窗口
发送方限制发送长度，保证缓冲区不溢出
### 拥塞控制
外部表现为丢包（溢出）延迟（排队）
**端到端拥塞控制**
由端系统通过延迟、数据丢失情况进行推断，控制
**网络辅助拥塞控制**
路由反馈网络拥塞信息给端系统
### TCP的拥塞控制
引入变量：CongWin-拥塞窗口
和接收窗口一起使用，发送的速率将取两者较小的一个
引入变量 Threshold-阈值，初始64KB
##### 加性增，乘性减
发生在CongWin>Threshold
**加性增**
每个RTT周期CongWin增加1单位Mss，直到检测到报文丢失
**乘性减**
检测到报文丢失时，CongWin和Threshold都设置为原CongWin一半
报文丢失说明网络能传输数据包
##### 慢启动
发生在CongWin<Threshold
CongWin开始时为1Mss
每次接收方接收到ACK时CongWin翻倍
直到发生了丢失事件
这样下载开始时发送方速度可以快速攀升
**超时事件**
如果发生了超时事件，Threshold设置为原CongWin一半，CongWin设置为1Mss
进入慢启动
超时说明网络拥塞不能传输