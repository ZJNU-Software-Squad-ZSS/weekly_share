# 0x6_操作系统

## 线程

​		线程是计算机中独立运行的最小单位，运行时占用很少的系统资源。由于每 个线程占用的CPU时间是由系统分配的，因此可以把线程看成操作系统分配CPU 时间的基本单位。在用户看来，多个线程是同时执行的，但从操作系统调度上看， 各个线程是交替执行的。系统不停地在各个线程之间切换，每个线程只有系统分 配给它的时间片内才能取得CPU的控制权，执行线程中的代码。

​		注意，这里只是针对单CPU单核的情况，在多CPU多核的主机上，多个线程 是可以同时运行的。Linux操作系统是支持多线程的，他在一个进程内生成了许 多个线程。一个进程可以拥有一至多个线程。 

​		虽然线程在进程内部共享地址空间、打开的文件描述符等资源。但是线程也 有其私有的数据信息，包括： 

- 线程号：（thread ID）：每个线程都有一个唯一的线程号与其对应 

- 寄存器（包括程序计数器和堆栈指针）、堆栈、信号掩码、优先级、线程私 有的存储空间。Linux系统支持POSIX多线程接口，称为pthread(Posix Thread的简 称)。编写Linux下的多线程应用程序，需要使用头文件pthread.h，链接时需要使用库libpthread.a。 

  创建线程： 

  线程创建函数pthread_create 

​        前面的程序实例都是单线程的。单线程的程序都是按照一定的顺序执行的， 如果在主线程里面创建线程，程序就会在创建线程的地方产生分支，变成两个程 序执行。这似乎和多进程一样，其实不然。子进程是通过拷贝父进程的地址空间 来实现的；而线程与进程内的线程共享程序代码，一段代码可以同时被多个线程执行。 

​		线程的创建通过函数pthead_create来完成，该函数的声明如下：

```c
#include<pthread.h> 
int  pthread_create(pthread_t *thread, pthread_attr_t * attr,void*(*start_routine)(void *),void *arg); 
```

​		注意：线程创建成功时，pthread_create函数返回0，若不为0则说明创建进程 失败。常见的错误码为EAGAIN和EINVAL。前者表示系统限制创建新的线程， 例如，线程数目过多；后者表示第2个参数代表的线程属性非法。线程创建成功后，新创建的线程开始运行第3个参数所指向的函数，原来的线程继续运行。 

​		pthead_create函数的第2个参数attr是一个指向pthread_attr_t结构体的指针，该 结构体指明待创建线程的属性。

​		在某些情况下，函数执行次数要被限制为一次，这种情况下就要使用 pthread_once函数。下面通过创建两个线程，两个线程分别 通过pthread_once调用同一个函数，结果被调用的函数只被执行了一次。

​		线程最大的特点就是资源的共享性，然而资源共享中的同步问题是多线程编 程的难点。Linux系统提供了多种方式处理线程间的同步问题，其中最常用的有互斥锁、条件变量和异步信号。

### 1.互斥锁 

​		互斥锁通过锁机制来实现线程的同步。在同一时刻它通常只允许一个线程执行关键部分的代码。下表列举了操作互斥锁的几个函数。这些函数均声明在头文 件pthread.h中。

​		使用互斥锁前必须先进行初始化操作。初始化有两种方式，一种是静态赋值法，将宏结构常量PTHREAD_MUTEX_INITIALIZER赋给互斥锁，操作语句如下：

```c
pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER; 
```

​		另外一种方式是通过pthread_mutex_init函数初始化互斥锁，该函数原型如下： 

```c
int pthread_mutex_init (pthread_mutex_t *mutex,const pthread_mutexattr_t *mutexattr);
```

### 2.条件变量 

​		条件变量是利用线程间共享的全局变量进行同步的一种机制。条件变量宏观 上类似if语句，符合条件就能执行某段程序，否则只能等待条件成立。 

​		使用条件变量主要包括两个动作：一个等待使用资源的线程等待“条件变量 被设置为真”；另一个线程在使用完资源后“设置条件为真”，这样就可以保证线程间的同步了。这样就存在一个关键问题，就是要保证条件变量能被正确的修改，条件变量要受到特殊的保护，实际使用中互斥锁扮演着这样一个保护者的角色。

### 3.异步信号 

​		在Linux操作系统中，线程是在内核外实现的，它不像进程那样在内核中实 现。Linux线程本质上是轻量级的进程。信号可以被进程用来进行互相通信，一 个进程通过信号通知另一个进程发生了某事件，比如该进程所需要的输入数据已 经就绪。线程同进程一样也可以接受和处理信号，信号也是一种线程同步手段。

 		信号（SIGINT和SIGIO）与任何线程都是异步的，也就是说信号到达线程的 时间是不定的。如果有多个线程可以接受异步信号，则只有一个被选中，如果并 发的多个同样的信号被送到一个进程，每一个将被不同的线程处理。如果所有的 线程都屏蔽该信号，则这些信号将被挂起，直到有信号解除屏蔽来处理它们。

​		Linux多线程扩展函数中有三个函数用于处理异步信号： 

```c
- int pthread_kill(pthread_t threadid,int signo); 
- int pthread_sigmask(int how,const sigset_t *newmask,sigset_t *oldmask); 

- int sigwait(const sigset_t *set,int *sig);  
```

​		其中，函数pthread_kill 用来向特定的线程发送信号signo 。函数 pthread_sigmask用来设置线程的信号屏蔽码，但对不允许屏蔽的Cancel信号和不 允许响应的Restart信号进行了保护。函数sigwait用来阻塞线程，等待set中指定的 信号之一到达，并将到达的信号存入*sig中。 

