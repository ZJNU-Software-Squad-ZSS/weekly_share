# 0x12_操作系统——死锁

2. ### 死锁的定义：

   - **是计算机系统中多道程序并发执行时，两个或两个以上的进程由于竞争资源而造成的一种互相等待的现象（僵局），如无外力作用，这些进程将永远不能再向前推进。**

3. ### 产生死锁的原因

   - **竞争资源**：**当系统中供多个进程所共享的资源，不足以同时满足它们的需要时，引起它们对资源的竞争而产生死锁**
     - 竞争非剥夺性资源
     - 竞争临时性资源
   - **进程推进的顺序不当** **：进程在运行过程中，请求和释放资源的顺序不当，导致进程的死锁。**

4. ### 产生死锁的四个必要条件

   - ### **互斥条件**:

     - 进程访问的是临界资源，那个资源一次只能被一个进程所使用。

   - ### **不剥夺条件**:

     - 一个资源仅能被占有它的进程所释放，而不能被其他进程剥夺。

   - ### **部分分配**:**（请求和保持条件）**

     - 一个进程在请求新的资源的同时，保持对某些资源的占有。

   - ### **环路等待条件**:

     - 存在一个进程的环路链，链中每一个进程占用有着某个或某些资源，又在等待链中的另一个进程占有的资源。

5. 死锁的排除方法

   - 鸵鸟算法（置之不理）：当死锁在计算机中很少出现

   - 预防死锁（使四个必要条件之一不能成立）

     - 互斥条件（由设备的固有特性所决定的，不仅不能改变，相反还应加以保证）

     - 防止部分分配：系统要求任一进程必须预先申请它所需的全部资源，而且仅当该进程的全部资源要求能得到满足时，系统才能给予一次性分配，然后启动该进程运行，但是在分配时只要有一种资源不满足，系统就不会给进程分配资源。进程运行期间，不会再请求新的资源，所以，再分配就不会发生（摒弃了部分分配）。

       特点：资源严重浪费、进程延迟进行

     - 防止不剥夺条件：一个已经保持了某些资源的进程，当它再提出新的资源要求而不能立即得到满足时，必须释放它已经保持的所有资源，待以后需要时再重新申请。

     - 防止环路等待条件：采用资源顺序使用法，基本思想是：把系统中所有资源类型线性排队，并按递增规则赋予每类资源以唯一的编号。例如输入机＝1，打印机＝2，磁带机＝3，磁盘＝4等等。进程申请资源时，必须严格按资源编号的递增顺序进行，否则系统不予分配。

   - 避免死锁：是在进程请求分配资源时，采用**银行家算法**等防止系统进入不安全状态

     - 安全状态：指系统能按照某种顺序如<P1,P2,…,Pn>

     - 非安全状态：即在某个时刻系统中不存在一个安全序列，则称系统处于不安全状态或非安全状态

       **避免死锁的实质是如何使系统不进入不安全状态。**

   - 检测和解除死锁

6. 银行家算法中的数据结构

   - 可利用资源向量Available：是一个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初值是系统中所配置的该类全部可用资源数目。如果Available[j]=k， 表示系统中现有Rj类资源k个
   - 最大需求矩阵Max：是一个含有n*m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max(i,j)=k， 表示进程i需要Rj类资源的最大数目为k。
   - 分配矩阵Allocation：是一个含有n*m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation(i,j)=k， 表示进程i当前已分得Rj类资源k个。
   - 需求矩阵Need：是一个含有nm的矩阵，用以表示每一个进程尚需的各类资源数。如果Need(i,j)=k， 表示进程i还需要Rj类资源k个，方能完成其任务。
     **Need(i,j)= Max(i,j)-Allocation(i,j)** 

7. ### 银行家算法

   设Requesti是进程Pi的请求向量，如果进程Pi需要K个Rj类资源，当Pi发出资源请求后，系统按下述步骤进行检查：

   1 如果**Requesti≤Needi**,则转向步骤2；否则认为出错。（因为它所需要的资源数已超过它所宣布的最大值。
   2如果**Requesti≤Available**,则转向步骤3；否则，表示系统中尚无足够的资源，Pi必须等待
   3 系统试探把要求的资源分配给进程Pi，并修改下面数据结构中的数值：
   **Available:=Available-Requesti;**
   **Allocation:=Allocation+Requesti;**
   **Needi:= Needi- Requesti;**
     4 系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，正式将资源分配给进程Pi，以完成本次分配；否则，将试探分配作废，恢复原来的资源分配状态，让进程Pi等待。 

8. ### 安全性算法

   系统所执行的安全性算法可描述如下：
   1 设置两个向量
   ①工作向量Work.它表示系统可提供给进程继续运行所需要的各类资源的数目，它含有m个元素，执行安全算法开始时，Work:=Available。
   ②Finish.它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish[i]:=false；当有足够的资源分配给进程时，令Finish[i]:=true.
   2 从进程集合中找到一个能满足下述条件的进程：①Finish[i]=false; ②Needi≤Work. 如找到，执行步骤3；否则执行步骤4。
   3 当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故执行：
   Work:=Work+Allocation;
   Finish[i]:=true;
   Goto step2;
   4 如果所有进程的Finish[i]=true，则表示系统处于安全状态；否则，系统处于不安全状态。 

9. 死锁的检测和恢复

   死锁的检测和恢复技术是指定期启动一个软件检测系统的状态，若发现有死锁存在，则采取措施恢复之。

   - 死锁的检测 ：实质是确定是否存在环路等待现象，一旦发现这种环路便认定死锁存在，并识别出该环路所涉及的有关进程，以供系统采取适当的措施来解除死锁。最常用的是一种基于资源分配图RAG和死锁定理的检测死锁算法。

     - ### 资源分配图（RAG）

       系统死锁可用资源分配图来描述，该图是由一组结点N和一组边E所组成的一对偶G=(N,E)。（用圆圈代表一个进程，用方框代表一类资源，由于一种类型的资源可能有多个，可用方框中的一个点代表一类资源中的一个资源）

       几个概念：请求边，分配边  

       - 封锁进程：是指某个进程由于请求了超过了系统中现有的未分配资源数目的资源，而被系统封锁的进程。
       - 非封锁进程：即没有被系统封锁的进程资源分配图的化简方法：假设某个RAG中存在一个进程Pi，此刻Pi是非封锁进程，那么可以进行如下化简：当Pi有请求边时，首先将其请求边变成分配边(即满足Pi的资源请求)，而一旦Pi的所有资源请求都得到满足，Pi就能在有限的时间内运行结束，并释放其所占用的全部资源，此时Pi只有分配边，删去这些分配边（实际上相当于消去了Pi的所有请求边和分配边），使Pi成为孤立结点。（反复进行）

       ![1fatT1.png](https://s2.ax1x.com/2020/02/09/1fatT1.png)

     - ### 死锁定理

       系统中某个时刻S为**死锁状态**的充要条件是**S时刻系统的资源分配图是不可完全简化的**。在经过一系列的简化后，若能消去图中的所有边，使所有的进程都成为孤立结点，则称该图是可完全简化的；反之的是不可完全简化的。

   - 死锁的恢复：与检测死锁相配套的一种措施，用于将进程从死锁状态下解脱出来。常用的方法有：

     - 撤消进程；最简单撤消进程的方法是使全部死锁的进程夭折掉；另一方法是按照某种顺序逐个地撤消进程，直至有足够的资源可用，死锁状态消除为止
     - 挂起进程（剥夺资源）。使用挂起/激活机构挂起一些进程，剥夺它们的资源以解除死锁，待条件满足时，再激活进程。目前挂起法比较受到重视。

