### 线程得创建、启动与运行
- 每个线程都有其要执行得任务。线程得任务处理逻辑可以在Thread类的run实例方法中直接实现或者通过该方法进行调用，因此run方法相当于线程的任务处理逻辑的入口方法，它由Java虚拟机在运行相应线程时直接调用，而不是由应用调到进行调用。
- 运行一个线程实际上就是让Java虚拟机执行该线程的run方法，从而使相应线程的任务处理逻辑代码得以执行。为此，我们首先要启动线程。Thread类的start方法的作用是启动相应的线程。启动一个线程的实质是请求Java虚拟机运行相应的线程，而这个线程具体何时能够运行是由线程调度器决定的。因此，start方法调用结束并不意味着相应线程已经开始运行，这个线程可能稍后才会被运行，甚至也可能永远不会被运行。
```
public class Demo01 {
    public static void main(String[] args) {
        //创建线程
        Thread welcomeThread = new WelcomeThread();
        //启动线程
        welcomeThread.start();
        //输出“当前线程”的线程名称
        System.out.println("1.Welcome! "+Thread.currentThread().getName());
    }
}

//定义Thread的子类
class WelcomeThread extends Thread{

    //在该方法中实现线程的任务处理逻辑
    @Override
    public void run() {
        System.out.println("2.Welcome! "+Thread.currentThread().getName());
    }
}
```

- 在Java平台中，一个线程就是一个对象，对象的创建离不开内存空间的分配。创建一个线程与创建其他类型的Java对象所不同的是，Java虚拟机会为每个线程分配调用栈（Call Stack）所需的内存空间。调用栈用于跟踪Java代码（方法）间的调用关系以及Java代码对本地代码的调用。
Java平台中的任意一段代码总是由确定的线程负责执行，这个线程就相应的被称为这段代码的执行线程。同一段代码可以被多个线程执行。

- 我们可以将Java中的线程分为守护线程（Daemon Thread）和用户线程（User Thread）。用户线程会阻止Java虚拟机的正常停止，即一个Java虚拟机只有在其所有用户线程都运行结束的情况下才能正常停止。而守护线程则不会影响Java虚拟机的正常停止，即应用程序中有守护线程在运行也不影响Java虚拟机的正常停止。因此，守护线程通常用于执行一些重要性不是很高的任务，例如用于监视其他线程的运行情况。
#### 线程的层次关系
- 假设A所执行的代码创建B，习惯上我们称线程B为线程A的子线程，相应地线程A就被称为B地父线程。
- 一个线程是否是一个守护线程默认取决于其父线程；默认情况下父线程是守护线程，则子线程也是守护线程；父线程是用户线程，则子线程也是用户线程。
- 一个线程地优先级默认值为该线程的父线程的优先级。
- 竞态产生的一般条件。设R1和R2是并发访问共享变量V的两个操作，这两个操作并非是读操作。如果一个线程在执行R1期间另外一个线程执行R2，那么无论R2是在读取还是更新V都会导致竞态。
- 一个类如果能够导致竞态，那么它是非线程安全的；如果一个类是线程安全的，那么它就不会导致竞态。

- Java有两种方式来实现原子性。一种是使用锁，另一种是使用利用处理器提供的专门CAS指令。
- 在Java语言中，long型和double型以外的任何类型的变量的写操作都是原子操作，即对基础类型（long/double除外，仅包括byte、boolean、short、char、float和int）的变量和引用型变量的写操作都是原子的。尽管如此，Java语言规范特别地规定对于volatile关键字修饰地long/double型变量的写操作具有原子性。

- 可见性问题与计算机的存储系统有关。程序中的变量可能会被分配到寄存器而不是主内存中进行存储。每个处理器都有其寄存器，而一个处理器无法读取另外一个处理器上的寄存器中的内容。因此，如果两个线程分别运行在不同的处理器上，而这两个线程所共享的变量却被分配到寄存器上进行存储，那么可见性问题就会产生。另外，即便某个共享变量是被分配到主内存中进行存储的，也不能保证该变量的可见性。这是因为处理器对主内存的访问不是直接访问，而是通过高速缓存子系统进行的。缓存同步使得一个处理器（上运行的线程）可以读取另一个处理器（上运行的线程）对共享变量所做的更新。

- 当一个进程中的一个线程由于时间片用完或其自身的原因被迫或主动暂停其运行时，另一个线程可以被操作系统（线程调度器）选中占用处理器开始或者继续其运行，称为上下文切换。
- 相应地，一个线程被剥夺处理器的使用权而被暂停运行就称为切出；一个线程被操作系统选中占用处理器开始或者继续其运行就称为切入。

- 自发性上下文切换线程由于自身因素导致的切出。从Java平台的角度来看，以下方法会引起上下文切换。
Thread.sleep()、Object.wait()、Thread.yield()、Thread.join()、LockSupport.park()
- 另外，线程发起了I/O操作或者等待其他线程持有的锁也会导致自发性上下文切换。
非自发性上下文切换是指由于线程调度器的原因被迫切出。导致非自发性上下文切换的常见原因包括被切出线程的时间片用完或者有一个比切出线程优先级更高的线程需要被运行。

- 锁的持有线程在其获得锁之后和释放锁之前这段时间内所执行的代码被称为临界区。因此，共享数据只允许在临界区内进行访问，临界区一次只能被一个线程执行。

- 一个锁实例可以保护一个或者多个共享数据。一个锁实例所保护的共享数据的大小就被称为该锁的粒度。一个锁实例所保护的共享数据的数量大，我们就称该锁的粒度粗，否则就称该锁的粒度细。锁的粒度过粗就会导致线程在申请锁的时候需要进行不必要的等待。

- Java平台中的任何一个对象都有唯一一个与之关联的锁，这种锁被称为监视器或者内部锁，内部锁是通过synchronized实现的。