刷LeetCode再到当时校网做题的误区就在于，我把思考如何解开题目本身当作目的，而不是把学习解题当目的。

接触动态规划也有一段时间了，但是刷动态规划tag下面的题目竟然还是在用其他的方法破题，每次都在周日匆匆写完提交了事，并没有认真看什么题解。

以[LeetCode121题](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)为例，未能实现动态方法的主要原因是对二维dp不熟悉，接着梳理时发现对动态规划学习得并不充分，下面为部分学习笔记，

后无效性：

如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。

最优子结构：大问题的最优解由小问题的最优解推出。

由最优子结构，得出状态转移方程。在自下向上的求解过程中，每一步都存储当前的值到容器中，最终得到目标n对应的解。

判断能否使用dp：**能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。**

回到刚开始的问题，为什么没有想出动态规划的方法来求解题目？

这道题能否拆分？如何拆分？

这道题是在求最大值，状态转移方程的结构必然为dp[i] = Math.max（x,y);

这个x与y会是什么？利润！，因此要用一个数组来存储利润，而利润必定用天数来标记。每一天，我可能有股票要抛出，也可能是有股票要买入。根据题目，当我有股票时不能再买入股票。因此这将每一天划分成两种情况，有股票的、没股票的。

但是股票又只能买一次，不持有股票又能分为“一开始就不持有股票”，“卖出股票后不再持有股票”。

思考到这一步，就能够得出缓存，状态 `dp[i][j]` 表示：在索引为 `i` 的这一天，用户手上持股状态为 `j` 所获得的最大利润。

j的含义：

```java
		 0：不进行任何操作
         1：用户执行了一次买入操作
         2：用户执行了一次卖出操作
```

那么x与y应该就是买与不买的最大利润，在最开始，买入股票意味着利润为负数，即-price[i],

卖出股票则+price[i]，

由此得到状态转移方程：

```java
	  dp[i][0] 永远等于 0
      dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])
      dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])
```

而我们可以将第0天设置为

```java
		dp[0][0] = 0;
        dp[0][1] = -prices[0];
        // 这里状态 2 不应该有值，设置为 0 不影响正确性
        dp[0][2] = 0;
```

至此，完成动态规划的题目思考。

同时，最大值问题只是取决于dp[i]与dp[i-1]之间的数量关系，因此可以进一步压缩成dp[i&1]与dp[i-1&1]。

状态转移方程更新为：

```java
 dp[i & 1][0] = Math.max(dp[(i - 1) & 1][0], dp[(i - 1) & 1][1] + prices[i]);
 dp[i & 1][1] = Math.max(dp[(i - 1) & 1][1], -prices[i]);
```



果然，学习题解是比自己想题更为耗时的，（不看题解只是在偷懒而已）

### REFERENCE:

------

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/bao-li-mei-ju-dong-tai-gui-hua-chai-fen-si-xiang-b/

什么是动态规划（Dynamic Programming）？动态规划的意义是什么？ - 知乎
https://www.zhihu.com/question/23995189