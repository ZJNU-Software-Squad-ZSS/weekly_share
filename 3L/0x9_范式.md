# 范式
- 第一范式（1NF）无重复的列

所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。

说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。

一个表里有一个“电话”字段，其值既有手机号，又有座机号 那么这样就不符合第一范式的要求了。此时应该将“电话”拆分为“手机”跟“座机” 这样一来就变成了一个符合第一范式的数据表了。

- 第二范式（2NF）属性完全依赖于主键[消除部分子函数依赖]
第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是唯一的，因此每个员工可以被唯一区分。这个唯一属性列被称为主关键字或主键、主码。
第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是属性完全依赖于主键。

- 第三范式（3NF）属性不依赖于其它非主属性[消除传递依赖]
满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。
a—>b b—>c。 那么c与a就是传递依赖，这样就不符合第三范式。而且不管a能不能直接确定c都属于传递依赖，所以只有b跟c不依赖于a以外的任何字段才符合第三范式

### 范式应用实例剖析

- 第一范式（1NF）：学校的学生系统中，数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。在当前的任何关系数据库管理系统（DBMS）中，这些DBMS不允许你把数据库表的一列再分成二列或多列。
　　
  学号、学生姓名、年龄、性别、课程、课程学分、系别、学科成绩，系办地址、系办电话等信息。
  
- 第二范式（2NF）实例分析
    
　　首先我们考虑，把所有这些信息放到一个表中(学号，学生姓名、年龄、性别、课程、课程学分、系别、学科成绩，系办地址、系办电话)下面存在如下的依赖关系。
  
　　（学号）→ (姓名, 年龄，性别，系别，系办地址、系办电话)
  
　　 (课程名称) → (学分)
 
　　 （学号，课程）→ (学科成绩)
  
  
- 问题分析
 
　　因此不满足第二范式的要求，会产生如下问题
  
　　数据冗余：同一门课程由n个学生选修，"学分"就重复n-1次；同一个学生选修了m门课程，姓名和年龄就重复了m-1次。
  
　　更新异常：
  
　　1)若调整了某门课程的学分，数据表中所有行的"学分"值都要更新，否则会出现同一门课程学分不同的情况。
  
　　2)假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有"学号"关键字，课程名称和学分也无法记录入数据库。
  
　　删除异常 ：假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同时，课程名称和学分信息也被删除了。很显然，这也会导致插入异常。
-  解决方案
　　把选课关系表SelectCourse改为如下三个表：
  
　　学生：Student(学号，姓名, 年龄，性别，系别，系办地址、系办电话)；
  
　　课程：Course(课程名称, 学分)；
  
　　选课关系：SelectCourse(学号, 课程名称, 成绩)。
-  第三范式（3NF）实例分析
　　接着看上面的学生表Student(学号，姓名, 年龄，性别，系别，系办地址、系办电话)，关键字为单一关键字"学号"，因为存在如下决定关系：
  
　　（学号）→ (姓名, 年龄，性别，系别，系办地址、系办电话)
  
　　但是还存在下面的决定关系
  
　　(学号) → (所在学院)→(学院地点, 学院电话)
  
　　即存在非关键字段"学院地点"、"学院电话"对关键字段"学号"的传递函数依赖。
  
　　它也会存在数据冗余、更新异常、插入异常和删除异常的情况。 
  
　　根据第三范式把学生关系表分为如下两个表就可以满足第三范式了：
  
　　学生：(学号, 姓名, 年龄, 性别，系别)；
  
　　系别：(系别, 系办地址、系办电话)。
  
　　总结：
　　上面的数据库表就是符合I,II,III范式的，消除了数据冗余、更新异常、插入异常和删除异常
 
## 函数依赖
- 关系各属性间相互制约而又相互依赖的情况。
  例：“姓名”和“所在系”函数依赖于“学号”，或者说“学号”函数决定“姓名”和“所在系”，记作：学号→姓名、学号→所在系。

- 设U{A1，A2，…，An}是属性集合，R（U）是U上的一个关系，x、y是U的子集。若对于R（U）下的任何一个可能的关系，   均有x的一个值对应于y的唯一具体值，称y函数依赖于x，记作x→y。    其中x称为决定因素。进而若再有y→x，则称x与y相互依赖，记作x←→y。

- 设R（U）是属性集U上的关系，x、y是U的子集，x’是x的真子集，若x→y且x’→y，则称y部分依赖x，记作X→PY。显然，当且仅当x为复合属性组时，才有可能出现部分函数依赖。    
例：课程号→课程名，课程号→开课教研室代码。
课程号十课程名→开课教研室代码：“开课教研室代码”部分函数依赖于课程号+课程名。

- 设R（U）是属性集U上的关系，x、y是U的子集，x’是x的真子集。若对于R（U）的任何一个可能的关系，有x→y但x’→y，则称y完全函数依赖于x，记作X→FY。

- 设R（U）是属性集U上的关系，x、y、z是U的子集，在R（U）中，若x→y，但y→x，若y→z，则x→z，称z传递函数依赖于x，记作X→TZ。       

## 闭包
- 定义：设X和Y均为关系R的属性集的子集，F是R上的函数依赖集，若对R的任一属性集B，一旦X→B，必有B⊆Y，且对R的任一满足以上条件的属性集Y1 ，必有Y⊆Y1，此时称Y为属性集X在函数依赖集F下的闭包，记作X＋。  
- 计算关系R的属性集X的闭包的步骤如下： 

　　第一步：设最终将成为闭包的属性集是Y，把Y初始化为X；
  
　　第二步：检查F中的每一个函数依赖A→B，如果属性集A中所有属性均在Y中，而B中有的属性不在Y中，则将其加入到Y中； 
  
    第三步：重复第二步，直到没有属性可以添加到属性集Y中为止。 最后得到的Y就是X＋
    
    例（1）：   设有关系模式R(U，F)，其中U={A，B，C，D，E，I}，F={A→D，AB→E，BI→E，CD→I，E→C}，计算(AE)+
    
        解:  (1) 令X={AE}，X(0)=AE
        
              (2)在F中寻找尚未使用过的左边是AE的子集的函数依赖，结果是: A→D， E→C；所以 X(1)=X(0)DC=ACDE， 显然 X(1)≠X(0).
              
              (3) 在F中寻找尚未使用过的左边是ACDE的子集的函数依赖， 结果是: CD→I；所以 X(2)=X(1)I=ACDEI。虽然X（2）≠X(1)，但F中寻找尚未使用过函数依赖的左边已经没有X（2）的子集，所以不必再计算下去，即(AD)+=ACDEI。
　　　            
               说白话一点：闭包就是由一个属性直接或间接推导出的所有属性的集合。
   
         例如：f={a->b，b->c，a->d，e->f}；由a可直接得到b和d，间接得到c，则a的闭包就是{a，b，c，d}
