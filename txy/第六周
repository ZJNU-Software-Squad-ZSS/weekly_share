全局最优：问题所有的可能解中效果最好的解。
局部最优：问题的部分可能解中效果最好的解。

一个针对的全局，一个针对的部分。
就像我们设初值一样，设置了以后函数开始迭代变化。
这时可能出现两种现象
①迭代到一个解，该解距离初值较近，此处该值很有可能是局部最优。
②迭代到一个解，该解距离初值相对较远，此处该值很大可能是全局最优，当然也可能是局部最优。


上面这个图相信大家看到过很多类似的，包括那个爬山坡的图在内，但是这里想强调的一点，这些图虽然很直观，但是也容易造成误解。我去……我一个求最优干嘛让我看这些图，我那些一堆公式，怎么才能和这些图对上呢？？？
这里就需要解释一下了：我们的求解其实都是迭代的过程，我们的函数在我们选择的起始点进行多个方向的尝试，看哪个反向能得到最优就向着哪个方向前进。那么什么是最优，这里我们的理性告诉我们，其他方向都比我差，我就是最优。是这样么？你是不是进入了一个小沟沟？这里就是局部了，你只能说你在你附近方圆几百里是最好的，但是地球那么大，你不想去看看么，这里就引入了全局最优，你是中国第一不行，你需要是全世界第一才行。

下面我们开始介绍我们matlab优化求解的函数
说到求解参数，我们需要先介绍下在求解最初设置的优化项。（下面两张图来自matlab官方）


下面介绍一下如何使用，以及常用项
①设置容差

options.TolX = 1e-15;%当前点 x 的终止容差。
options.TolFun = 1e-15;%函数值的终止容差。
1
2
②设置最大迭代次数

options.MaxIter=1000;
1
③设置求解上下限和初始值

%上边界
LB = [100,0,0,0.50,1,-1,700];
% 下边界
UB = [20000,900,360,11,20,20,90];
% 优化初始值
x0 = [1000 500 270 200 9 15 80 ];
1
2
3
4
5
6
设置完这些，我们就可以开始我们的待优化函数构造+优化程序编写了。

①fminbnd（求单变量非线性的极小值）（局部最优）
单变量非线性——现在很多问题都是多变量的，这个函数不知道大家用不用，我是用的比较少的
算法介绍
fminbnd 是一个函数文件。算法基于黄金分割搜索和抛物线插值方法。除非左端点 x1 非常靠近右端点 x2，否则 fminbnd 从不计算 fun 在端点处的值，因此只需要为 x 在区间 x1 < x < x2 中定义 fun。

示例
x = fminbnd(fun,x1,x2) 返回一个值 x，该值是 fun 中描述的标量值函数在区间 x1 < x < x2 中的局部最小值。
x = fminbnd(fun,x1,x2,options) 使用 options 中指定的优化选项执行最小化计算。使用 optimset 可设置这些选项。
x = fminbnd(problem) 求 problem 的最小值，其中 problem 是一个结构体。

fun = @cos;%% 或者fun = @(x)cos(x);
x1 = -pi;%下限
x2 = pi;%上限
options = optimset('Display','iter');%该设置表示在求取中，显示迭代过程。
options = optimset('PlotFcns',@optimplotfval);%该设置表示在求取中，绘制迭代图。
[x,fval] = fminbnd(fun,x1,x2,options)%x是取最值的x，最值是fval。
1
2
3
4
5
6
结果分析
[x,fval,exitflag,output] = fminbnd(___)
x - 解
实数标量

fval - 解处的目标函数值
实数

exitflag - fminbnd 停止的原因
整数

output - 有关优化过程的信息
结构体


该算法的局限性
1.要计算最小值的函数必须是连续的。
2.fminbnd 只能给出局部解。
3.当解在区间的边界上时，fminbnd 可能表现出慢收敛。
