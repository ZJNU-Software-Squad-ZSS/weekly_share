

# 软件测试的复杂性与经济性

## 复杂性

- 无法对程序进行完全测试

- 不能修复所有的软件故障

  1. 没有足够时间修复

  2. 修复风险大

  3. 不值得修复

  4. 可以不看做故障的缺陷

     这里会出为什么？答：测试时间和人员有限，由于软件的复杂性，测试用例数和软件的程序路径会非常多，所以不能把所有缺陷发现（缺陷无法保证被程序中无遗留错误），软件测试是有风险的

  

## 经济性

软件测试工作的原则：如何将无边无际的可能性减小到一个可以控制的范围，以及如何针对风险做出恰当的选择，去粗取精，找到最佳的测试量，使得测试工作量不多不少，既能达到测试的目的，又较为经济。

* ### 影响测试量的因素：

1. 系统的目的：系统目的差别影响测试量
2. 用户数量
3. 信息价值
4. 开发机构
5. 测试时机：根据市场状况确定（去获取市场资源）

## 软件测试方法：

等课件上的图

- 静态测试：可能连代码都没写，然后就开会审查.不运行程序

- 动态测试：运行程序来看效率与结果
  1. 功能确认与接口测试
  2. 覆盖率测试
  3. 性能分析
  4. 内存分析

- 黑盒测试：数据驱动测试
  1. 等价类划分
  2. 因果图法
  3. 边界值分析
  4. 决策表测试
  5. 错误推测法
  

这里放黑白盒测试比较



- 结构测试：逻辑驱动测试

- 回归测试：

  1. 原因：在软件开发任何阶段，软件发生变化，就必须进行重新测试原有的功能。确定软件的修改是否达到预期的目的。检查修改是否损害了原有的功能。

  2. 方法：对修改过的代码重新运行现有的测试，确定更改是否破坏了在更改之前有效的任何事物。

     

 确认测试：又称有效性测试。他的任务是验证软件的有效性。即验证软件功能和性能及其他特性是否与用户的要求一致。

主要活动：进行有效测试

软件配置复查



## 软件测试的阶段

- ### 单元测试：
  
  单元测试是对软件基本组成单元进行测试，主要是为了发现单元内部可能存在的各种错误和不足。

  1. 步骤为两个：人工静态检查和动态执行跟踪
  2. 一般由开发组在开发组长的监督下进行
  
  * 什么是单元：
    - 一个函数
    - 类或类内成员函数
    - 几个函数的集合
  
  这里放上单元测试环境的图
  
- ### 集成测试：

    在单元测试的基础上，将所有模块按照概要设计要求组装成为子系统或系统所进行的测试

  集成测试的重点

  * 模块接口的数据交换
  * 各模块组合起来能否到达预期要求的父功能
  * 模块间是否有不利的影响
  * 全局数据结构
  * 单个模块的误差是否会累计放大

- 

- 单元测试与集成测试的区别：
  
     这里放图
  
- 集成方法
  
     ==大爆炸集成==：一次性组装，尽可能缩短测试时间，使用最少的测试用例验证系统。
  
  + 优点
    1. 可以并行测试所有模块
    2. 需要的测试用例少
    3. 测试方法简单、易行
  + 缺点
    1. 不可避免存在模块间接口、全局数据结构等方面的问题，所以一次运行成功的可能性不大
    2. 可能会出现大量错误。修改一个错误之后，可能会出现更多错误
    3. 即使通过测试，也会遗漏很多错误

​       ==自顶向下==：
​    优点：较早地验证了主要控制和判断点；按深度优先可以首先实现和验证一个完整的软件功能；功能较早证实，带来信     心；只需一个驱动，减少驱动器开发的费用；支持故障隔离。
缺点：柱的开发量大；底层验证被推迟；底层组件测试不充分。
适应于产品控制结构比较清晰和稳定；高层接口变化较小；底层接口未定义或经常可能被修改；产口控制组件具有较大的技术风险，需要尽早被验证；希望尽早能看到产品的系统功能行为。

​     ==自底向上==：

  优点：对底层组件行为较早验证；工作最初可以并行集成，比自顶向下效率高；减少了桩的工作量；支持故障隔离。
缺点：驱动的开发工作量大；对高层的验证被推迟，设计上的错误不能被及时发现。
适应于底层接口比较稳定；高层接口变化比较频繁；底层组件较早被完成。

​    ==三明治集成==：

  优点：集合了自顶向下和自底向上两种策略的优点
  缺点：中间层测试不充分
  适应于大部分软件开发项目

   ==优先测试使用次数高的模块，核心模块==



- 系统测试：
- 

是将集成好的软件系统，作为整个基于

   

* 恢复测试：要证实在克服硬件故障（包括掉电、硬件或网络出错等），系统能否正常地继续进行工作，并不对系统造成任何损害。

  错误探测功能——系统能否发现硬件失效与故障；

  能否切换或启动备用地硬件

  在故障发生时能否保护正在运行地作业和系统状态

  在系统恢复后能否从最后记录下来地无错误状态



* 安全测试：要检验在系统中已经存在地系统安全性、保密性措施是否发挥作用，有无漏洞，以检查系统对非法侵入地防范能力。

  测试人员扮演非法入侵者

  系统安全设计地准则是：使非法侵入地代价超过被保护信息的价值

* 可靠性测试：是为了检验系统的可靠性是否达到预期目标而进行的测试
  
1. 平均失效间隔时间MTBF（Mean Time Between Failures)是否超过规定时限
2. 一年中应不超过多少时间MTRR

* 安装测试：他的目的不是找软件错误，而是找安装错误。就是要找出在这些安装过程中出现的错误，验证成功安装系统的能力。是软件开发后的过程。但是是用户使用的第一个过程
  * 容量测试：让系统在极限状态下是否能保持正常运行

* 文档测试

* 验收测试：以用户为主，使用一般生活中的实际数据进行测试

* 面向对象软件测试：

  1. 面向对象的单元测试 ：类测试，对一个类去测试

  2. 面向对象的集成测试 ：类簇测试。类簇是指一组相互有影响，联系比较紧密的类。例如子类与父类的继承与一致性。
     	* 基于类间协作关系的横向测试
        	* 基于类间继承关系的纵向测试

  3. 面向对象的系统测试 

# ==第三章==

## 黑盒测试:

​	称为功能测试或数据驱动测试。一开始把测试只当成功能的测试，所以只关注功能。把软件看成一个黑盒子，完全不考虑软件的内部结构和处理软件。只是在程序的接口进行测试，已检查功能是否正常，软件是否 能适当接收输入数据产生正确的输出数据。

```html
* 检查软件功能是否按照需求规格说明书的规定，测试每个功能是否有遗漏，检查性能等特性要求是否满足要求
* 检查模块接口是否存在问题
* 检查软件初始化和终止方面的错误
```

1. 边界值测试：

   把任何程序都看成一个函数

   原理：错误更可能出现在输入、输出的极值附近

   单输入：输入7个值。ppt上是输入5个。多了比min更小的，比max更大的。

   单因素出错时的测试用例：$$6*n+1$$,这是输入7个。  输入为5个时，为$$4*n+1$$

   当多因素一起出错时，为$$5^n$$,输入为7时，$$7^n$$.==这个叫最坏情况测试==，==7是健壮性最坏情况测试==

   输入为7的叫==健壮性测试==

   ### ==n取决与输入的个数==

2. 等价类测试：

   动机：1. 进行完备的测试      2. 无冗余性

   + 有效等价类：对于程序的规格说明来说是合理的、有意义的输入数据构成的集合。利用有效等价类可检验程序是否实现了规格说明所规定的功能和性能

   + 无效等价类：对程序的规格说明是不合理的或无意义的输入数据所构成的集合。对于具体的问题，无效等价类至少应有一个，也可能有多个。

   例子：0~100分。x < 0 与x > 100为等价类，0<x<60为等价类



弱：单缺陷假设（单因素引起）				强：多缺陷假设（多因素引起）

一般：只考虑有效值		健壮：考虑无效值

弱一般：$$max \{n_1, n_2,n_3,....n_k\}$$

弱健壮：一般默认使用弱健壮来作为测试方法

强一般:   

强健壮：



等价类划分方法：



3. 在输入条件是一个布尔量的情况下，可确定一个有效等价类和一个无效等价类

### 决策表：

1. 条件桩
2. 行动桩
3. 一列为一条规则
4. 根据离散数学的真值表

### 因果图

一种可视化的表达方式，用图的方式表达都能用布尔量表示的输入、输出变量之间的逻辑关系。

因：是需求说明里能够产生输出的任何条件

果：是一些输入条件组合导致的系统的响应

* 原因与结果之间的关系：

​        恒等、非、或、与

* 原因与原因之间的约束关系

​         互斥（Exclusive）当一个原因出现是，不能出现另外一个.都没有是特殊现象；包含（I）原因中至少有一个必须成立；唯一（only）不管多少的元素，必须有唯一一个出现；要求（R）当c1出现时，c2必须出现。当c1不出现时，c2不一定出现

* 结果与结果之间约束关系

    屏蔽（强制）当E1为1时，E2必须为0.当E1为0时，E2的值不一定。

​		