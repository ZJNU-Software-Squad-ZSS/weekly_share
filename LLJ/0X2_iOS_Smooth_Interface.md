#  iOS开发之流畅界面的开发
- 界面卡顿产生原因及解决方案
- 开发流畅界面 - ASDK（AsyncDisplayKit）

## 卡顿产生的原因和解决方案

### 屏幕图像显示原理

屏幕由像素点阵组成。可以分割成有限多行的像素。

>
* 假设屏幕左上角坐标为（0，0）
* 水平方向向右为x轴正向，垂直方向向下为y轴正向
* 点阵的x，y轴坐标均从0到Max。


1. 使得屏幕得以成像的电子枪会从（0，0）点开始
先以y轴不变，x轴从0至max扫描电子，完成一行像素的呈现。
2. 此时显示器会发出一个水平同步信号（HSync：Horizontal Synchronization）提示电子枪可跳转到新的一行，此时y轴值+1，x轴值归0.
3. 重复向右及向下跳转的过程，直到完成所有行的扫描。电子枪将接受一个垂直同步信号（VSync：Vertical Synchronization），电子枪复原到（0，0）位。此时完成整幅画面的一帧的呈现
4. 重复1-2-3步骤完成下一帧扫描。


>常听到的屏幕刷新率就是这里的`VSync`.

### 计算机系统中的图像显示原理

CPU计算好显示内容提交给GPU
GPU渲染后放入帧缓冲区
视频控制器按照VSync信号逐行读取帧缓冲区的数据
视频控制器通过数模转换传递给显示器显示

因为单帧缓冲区都会有比较大的读取和刷新问题，
所以iOS设备始终使用的是双帧缓冲区并开启垂直同步。
双缓冲区即两个缓冲区交替使用；这样当视频控制器在其中一个缓冲区读取内容的时候，GPU可将新的一帧内容放在第二缓冲区，并调整视频控制器的指针到第二缓冲区。

> 为什么开启垂直同步

双缓冲区存在一个问题：
有时候GPU控制指针过快，会导致前一帧读取一半就被拉来读后一帧，因此会造成画面撕裂（如图）。

GPU中的机制：`垂直同步` 就可以解决这个问题，开启垂直同步以后，GPU会等待显示器的VSync信号发出以后才进行新的一帧的渲染和缓冲区更新。
这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，带来延迟。

* 安卓系统是三缓存+垂直同步

### 卡顿产生原因

因为有垂直同步，如果CPU或GPU没有在一个同步时间单位内完成内容的提交，那一帧就会被丢弃，等待下一次机会再显示
此时显示屏会停留在之前的内容保持不变。这就是界面卡顿的原因。

解决方法就是对CPU和GPU压力进行评估和优化。

### CPU资源消耗原因和解决方案

* 对象创建

对象的创建会分配内存、调整属性、甚至还有读取文件等操作。比较消耗CPU资源。应尽量用轻量对象代替重量的对象，可以对性能有所优化。
比如`CALayer`比`UIView`要轻量许多，不需要响应触摸事件的控件，用`CALayer`显示会更加合适。
如果对象不涉及UI操作，则尽量放到后台线程去创建。（包含`CALayer`的控件都只能在主线程创建和操作）
通过`Storyboard`创建视图对象时，其资源消耗会比直接通过代码创建对象要大，在性能敏感界面，`Storyboard`并不是一个好的技术选择。
尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。
如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。

* 对象调整

对象的调整也经常是消耗 CPU 资源的地方。特别的 `CALayer：CALayer` 内部并没有属性，当调用属性方法时，它内部是通过运行时 `resolveInstanceMethod` 为对象临时添加一个方法，并把对应属性值保存到内部的一个 `Dictionary` 里，同时还会通知 `delegate`、创建动画等等，非常消耗资源。
`UIView` 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 `CALayer` 属性映射来的，所以对 `UIView` 的这些属性进行调整时，消耗的资源要远大于一般的属性。在应用中，应该尽量减少不必要的属性修改。
当视图层次调整时，`UIView`、`CALayer` 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。

* 对象销毁

对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。
通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。
同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。
Tip：把对象捕获到 `block` 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。

    NSArray *tmp = self.array;
    self.array = nil;
    dispatch_async(queue, ^{
        [tmp class];
    });

* 











