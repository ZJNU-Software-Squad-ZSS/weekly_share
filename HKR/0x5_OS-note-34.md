# 3. 处理机调度与死锁（续）

## 死锁

对系统中所有进程的资源分配工作，都由OS完成

··· 可抢占资源：资源占有进程虽然需要使用该资源，但另一个进程却强行把资源从占有者进程处抢来。
··· 不可抢占资源：只有占用者进程主动释放资源，其它进程不得强行抢占。

资源：

1. CPU、主存、硬盘，该类资源可为几个进程共同使用（可抢占）
2. 打印机，读卡机，磁带驱动器，可为某个进程独享（不可抢占）

#### 死锁的定义：

计算机系统中多道程序并发执行时，两个或两个以上的进程由于竞争资源而造成的一种互相等待的现象（僵局），如无外力作用，这些进程将永远不能再向前推进。

陷入死锁状态的进程称为**死锁进程**



#### 产生死锁的原因：

1. 竞争资源：系统中供多个进程所共享的资源，不足以同时满足它们的需要，引起对资源的竞争而产生死锁；
2. 进程推进的顺序不当：进程在运行过程中，请求和释放资源的顺序不当，导致进程的死锁。



#### 产生死锁的四个必要条件：

1. 互斥条件：进程访问的是临界资源，那个资源一次只能被一个进程所使用。
2. 不剥夺条件：一个资源仅能被占有它的进程所释放，而不能被其他进程剥夺。
3. 部分分配：（请求和保持条件）一个进程在请求新的资源的同时，保持对某些资源的占有。
4. 环路等待条件：存在一个进程的环路链，链中每一个进程占用有着某个或某些资源，又在等待链中的另一个进程占有的资源。



#### 死锁的排除方法：

##### 1. 鸵鸟算法

当死锁在计算机中很少出现时，忽略它。

##### 2. 预防死锁

根据生产死锁的四个必要条件，只要使用其中之一不能成立，死锁就不会出现。

（1）防止部分分配：仅当该进程的全部资源要求能得到满足时，系统才能给予一次性分配，

​						缺点：资源严重浪费、进程延迟进行

（2）防止“不剥夺”条件的出现：一个已经保持了某些资源的进程，当它再提出新的资源要求而不能立即得到满足时，必须释放它已经保持的所有资源，待以后需要时再重新申请。

​						缺点：反复申请和释放资源，延长周转时间，增加系统的开销，降低系统吞吐量。

（3）防止“环路等待”条件的出现：采用资源顺序使用法，把系统中所有资源类型线性排队，并按递增规则赋予每类资源以唯一的编号。

​						优点：资源利用率和系统吞吐量与另两种方法相比有较明显的改善。

​						缺点：为系统中各种类型的资源所分配的序号必须相对稳定，这就限制了新设备类型的增加； 									作业实际使用资源的顺序与系统规定的顺序不同而造成资源的浪费



##### 3. 避免死锁

在进程请求分配资源时，采用银行家算法等防止系统进入不安全状态。

··· 安全状态：指系统能按照某种顺序如<P1,P2,…,Pn>(称为<P1,P2,…,Pn>序列为安全序列)，为每个进程分配所需的资源，直至最大需求，使得每个进程都能顺利完成。

··· 非安全状态：即在某个时刻系统中不存在一个安全序列，则称系统处于不安全状态或非安全状态。

**避免死锁的实质**是如何使系统不进入不安全状态。

**银行家算法**：

 设Requesti是进程Pi的请求向量，如果进程Pi需要K个Rj类资源，当Pi发出资源请求后，系统按下述步骤进行检查：

（1）如果Requesti≤Needi,则转向步骤2；否则认为出错。（因为它所需要的资源数已超过它所宣布的最大值。

（2）如果Requesti≤Available,则转向步骤3；否则，表示系统中尚无足够的资源，Pi必须等待

（3）系统试探把要求的资源分配给进程Pi，并修改下面数据结构中的数值：
Available:=Available-Requesti;
Allocation:=Allocation+Requesti;
Needi:= Needi- Requesti;

（4）系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，正式将资源分配给进程Pi，以完成本次分配；否则，将试探分配作废，恢复原来的资源分配状态，让进程Pi等待。



##### 4. 检测和解除死锁：

<u>死锁的检测</u>： 
      实质是确定是否存在环路等待现象。最常用的是一种基于资源分配图RAG和死锁定理的检测死锁算法。

封锁进程：是指某个进程由于请求了超过了系统中现有的未分配资源数目的资源，而被系统封锁的进程。

死锁定理：系统中某个时刻S为死锁状态的充要条件是S时刻系统的资源分配图是不可完全简化的。

<u>死锁的恢复</u>：

1. 撤消进程；最简单撤消进程的方法是使全部死锁的进程夭折掉；另一方法是按照某种顺序逐个地撤消进程，直至有足够的资源可用，死锁状态消除为止

2. 挂起进程（剥夺资源）。使用挂起/激活机构挂起一些进程，剥夺它们的资源以解除死锁，待条件满足时，再激活进程。目前挂起法比较受到重视。





# 4.存储管理：

![image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/4.1.png)

## 程序的装入和链接

### 程序的装入：

1. 绝对装入方式（Absolute Loading Mode）
2. 可重定位装入方式（Relocation Loading Mode）：当一个地址装入与其地址空间不一致的存储空间中，就得要地址变换。也就是说将虚地址映射为内存地址，把这种作法叫做地址重定位
3. 动态运行时的装入方式（Denamle Run-time Loading)：地址转换推迟到程序真正要开始执行时才进行。

### 程序的链接：

1. 静态链接：程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装配模块，以后不再拆开。
2. 装入时动态链接：将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的方式。
3. 运行时的动态链接：对某些目标模块的链接时在程序执行中需要该模块是才对它进行链接。



存储管理的目的：尽可能方便用户和提高主存储器的使用效率，使主存储器在成本、速度和规模间获得较好权衡。

存储器管理的功能：

1. 主存空间分配和保护
2. 主存空间的重定位
3. 主存空间的共享
4. 主存空间的扩充

#### 地址变换

··· 逻辑地址（相对地址）：**程序**用来访问信息所用的一系列的地址单元。
··· 物理地址（绝对地址）：**主存**中一系列存储物理单元。

地址空间是逻辑地址的集合。存储空间是物理地址的集合。

地址重定位：

1. 静态重定位：将程序或作业中的指令和数据的逻辑地址一次性全部转换成物理地址。

   ![image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/4.2.png)

2. 动态重定位：地址转换是在程序执行过程中需要访问数据时再进行地址变换。

   ![image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/4.3.png)



### 存储管理方式

![image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/4.4.png)

