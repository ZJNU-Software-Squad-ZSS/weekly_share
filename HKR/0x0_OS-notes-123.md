# 1. 绪论

## 1.1 计算机体系结构

#### 计算机系统的组成

计算机系统：由<u>计算机硬件</u>和<u>计算机软件</u>两部分组成

![Image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/1.1.png) 

#### 计算机硬件和软件的关系
![Image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/1.2.png) 

## 1.2 操作系统

#### 操作系统的定义

<font color=red>操作系统</font>：控制和管理计算机系统硬件和软件资源、合理地组织计算机工作流程，以方便用户使用的程序的集合。
![Image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/1.3.png) 

**···单道批处理系统**：内存中始终只保持一道作业

**···多道批处理系统**：多个程序装同时入内存，交替运行，共享系统中的各种硬件和软件资源

**···分时操作系统**：

同时允许多个用户通过自己的终端，以交互方式使用计算机，共享主机中的资源

![Image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/1.4.png) 

分时系统特点：多路性、独立性、<font color=red>及时性、交互性</font>



**···实时系统**：

能够及时响应随机发生的外部事件，在严格的时间范围内，完成对该事件的处理，并控制所有实时任务协调一致地运行。

实时系统特点：及时性、交互性、独立性、高可靠性



**···通用操作系统**：兼有分时、实时和批处理三者或其中两者的操作系统称为通用操作系统



**···网络操作系统**：

具有网络通信和网络服务功能的操作系统

工作模式：客户机/服务器（C/S）模式 和 对等模式（P2P）



**···分布式操作系统**：

通过通信网络方式，将地理上分散的、具有自治功能的多台分散的计算机通过互联网连接而成的系统，以实现信息交换和资源共享，协作完成指派的任务

每台计算机既高度自治，又互相协同，能在系统范围内实现资源管理、任务分配，能并行地运行分布式程序

特点：分布性、并行性、透明性、共享性、健壮性



#### 操作系统的特征

1. <font color=red>并发</font>：两个或两个以上事件在同一时间间隔内发生

2. 并行：某一时刻两个或多个事件在同时运行

3. <font color=red>共享</font>：互斥共享，同时访问

4. 临界资源（独占资源）：指一段时间内只允许一个进程访问的资源



# 2. 进程管理

**进程**：一个具有一定独立功能的程序关于<u>某个数据集合</u>的一次运行活动。它是操作系统进行<u>资源分配和调度的基本单位</u>。

特点：动态性、并发性、独立性、异步性、结构特性（由程序段、数据段、进程控制块组成）

 

**进程的三种基本的状态**

1. 就绪状态（Ready）：已经分配到了除CPU外的所需资源。
2. 运行状态（Running）：进程已经获得处理机，其程序正在执行。
3. 阻塞状态（Blocked）：也可以称为等待状态。进程因为发生某个事件而暂停执行的状态。



新状态：一个进程刚刚建立，但还没有将它送入就绪队列的状态。 

终止状态：进程结束，OS已经将它从就绪队列中移出，但还没有将它撤消时的状态。

![Image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/2.1.png) 

操作系统无法预期进程的数目与资源需求，计算机系统正在运行过程中可能出现资源不足的情况，具体表现为系统性能低和陷入死锁状态。

解决方法：剥夺某些进程的资源，调入OS管理的对换区，适当的时候再重新调入内存，恢复资源，参与运行，这就是**挂起**；和挂起动作刚好相反的动作是**激活**。

![Image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/2.2.png) 



PCB的组织方式：链接方式、索引方式


## 进程控制

处理机的状态分为<font color=red>系统态</font>和<font color=red>用户态</font>

OS内核
**原语**：系统状态下执行的某些具有特定功能的程序段称为原语。
**原子操作**：一个操作中的动作要么全做，要么全不做。



## 进程同步与互斥

**进程的制约关系：**
1.间接制约关系（进程互斥）：由于共享资源而引起的在临界区内不允许并发进程交叉执行的现象。由共享公有资源而造成的对并发进程执行速度的间接制约
2.直接制约关系（进程同步）：由于并发进程互相共享对方的私有资源所引起的直接制约。

**临界资源**：一次只允许一个进程访问的资源。临界资源在任何时刻不允许两个及以上并发进程同时访问。
**临界区**：指进程访问临界资源的那段程序代码

**临界区的管理**：1 空闲让进；2 忙则等待；3 让权等待；4 有限等待；

**P原语**操作的主要动作
S－1
如果S－1以后仍大于等于零，则进程继续进行
如果S－1以后小于零，则将该进程阻塞以后插入阻塞队列，然后转进程调度

**V原语**操作的主要动作
S＋1
如果相加后结果大于零，则继续进行
相加后结果小于等于零，则从该信号的等待队列中唤醒一个等待进程，然后返回原进程继续执行或者转进程调度。



## 实际问题的解决

#### 生产者——消费者问题

设：公用信号量 mutex     仓库这个公用资源的状态     初值为1

​     （消费者）私用信号量 full    表示仓库产品的个数         初值为0

​     （生产者）私用信号量 avail  表示仓库中空位置的个数     初值为n

> deposit（data）：         
>
>    begin
>
> ​     P(avail)          检查仓库中是否有空位   执行后n-1
>
> ​     P(mutex)          检查仓库是否可用      执行后 mutex＝0
>
> ​     将产品送入仓库 
>
> ​     V(full)           将产品的个数加1
>
> ​     V(mutex)         释放仓库这个资源
>
>    end

 

> Remove（data）：
>
>    begin
>
> ​     P(full)           检查仓库中是否有产品
>
> ​     P(mutex)          检查仓库是否可以使用
>
> ​     从仓库中取出一个产品
>
> ​     V(avail)           将空位置的个数加1
>
> ​     V(mutex)           释放仓库这个资源
>
>    end  



#### 利用信号量解决读者和写者问题

一个文件可能被多个进程共享，为了保证读写的正确性和文件的一致性，系统要求，当有读者进程读文件时，不允许任何写者进程写，但允许多读者同时读；当有写者进程写时，不允许任何其它写者进程写，也不允许任何读者进行读。

设：

（1）互斥信号量rmutex,用于使读者互斥地访问共享变量readcount,这里readcount是记录有多少读者正在读; 

（2）互斥信号量wmutex,用于实现读写互斥。读者—者问题进行如下描述：

> cobegin
>
> void ***\*readeri\****(void)(i=1,2,…k) 
>
>  {
>
>  while(true){       
>
>    p(rmutex)；
>
>  if readcount=0 then  p(wmutex);         
>
>    readcount:=readcount+1;   
>
>    v(rmutex);         
>
>    读文件；
>
> ​    … 
>
>    p(rmutex)； 
>
>    readcount:=readcount-1;
>
> if readcount=0 then  v(wmutex);
>
>    v(rmutex);
>
> ​     }
>
>   }

 

> void ***\*writerj\****(void)(j=1,2,…,m)
>
>   {
>
>    while(true){
>
>    p (wmutex);
>
>    写文件；
>
>    v(wmutex)；}
>
>   }
>
> coend



#### 图书馆阅览室问题

假定阅览室最多可同时容纳100个人阅读，读者进入时，必须在阅览室门口的一个登记表上登记，内容包括姓名、座号等，离开时要撤掉登记内容。用P、V操作描述读者进程的同步算法。

信号量s，代表空座位的数目；

设一个用于互斥的信号量mutex,防止2个及以上的读者进程同时对此表访问

> struct semaphore s,mutex=100,1;
>
> cobegin 
>
> void readeri(void) (i=1,2,…,k)
>
>   	{ 
>
> ​    	while(TRUE){
>
> ​			P(s);
>
> ​      P(mutex);
>
> ​			查登记表，置某座位为占用；
>
> ​			V(mutex);
>
> ​			……
>
> ​			reading;
>
> ​      ……
>
> ​      P(mutex);
>
> ​      登记表，置某座位为空;
>
> ​			V(mutex);
>
> ​      V(s);}
>
> ​		}
>
> coend



## 线程的引入

线程是进程中的一个实体，是被<u>系统独立调度和分配的基本单位</u>

**线程与进程的主要区别**

1.进程是资源管理的基本单位，它拥有自己的地址空间和各种资源；线程只是处理机调度的基本单位，它只和其他线程一起共享进程资源，它自己没有任何资源。

2.以进程为单位进行处理机切换和调度时，处理机切换时间长，资源利用率降低。以线程为单位进行进行处理机切换和调度时，由于不发生资源变化，特别是地址空间的变化，处理机切换时间较短，从而处理机效率较高。



# 3. 处理机的调度与死锁

#### 作业的状态及转换

![Image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/3.1.png) 

#### 作业的性能衡量

1. 周转时间：

![Image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/3.2.png) 

作业的周转时间=作业的完成时间-作业向系统提交的时间

 ![Image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/3.3.png) 


作业的周转时间=作业的等待时间+作业的执行时间

 

2. 作业平均周转时间

![Image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/3.4.png) 



3. 作业带权周转时间：该作业的周转时间与所需运行时间之比

 ![Image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/3.5.png) 

#### 

4. 作业平均带权周转时间

 ![Image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/3.6.png) 

#### 

5. 响应比：作业的周转时间与它所需的执行时间之比

![Image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/3.7.png) 

#### 

#### 进程调度

具有三级调度的调度队列模型

![Image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/3.8.png) 



#### 作业调度算法和进程调度算法

1. 先来先服务调度算法（FCFS）

将用户**作业**和就绪**进程**按提交顺序或变为就绪状态的先后排成队列，并按照先来先服务的方式进行调度处理，是一种最普遍和最简单的方法。它优先考虑在系统中等待时间最长的作业，而不管要求运行时间的长短。

 

2. 短者优先调度算法（SJF，SPF）

优先调度要求运行时间最短的**作业**

 

3. 最高响应比**作业**优先算法（HRN）

最高响应比作业优先算法是对FCFS方式和SJF方式的一种综合平衡。

响应比R定义为系统对作业的响应时间与作业要求运行时间的比值。

**每次都要重新计算响应比**

 

4. 轮转法RR

时间片轮转法主要用于**进程**调度

就绪队列往往按进程到达的时间来排序

被抢占的进程回到就绪队列的末尾重新排队

 

5. 优先级调度算法

将处理机分配给具有最高优先级的**进程**（用于实时系统）

分为静态优先级和动态优先级

 

6. 多级反馈队列调度算法

设置多级就绪队列；

各级就绪队列具有不同大小的时间片；

按队列优先级高到低进行进程调度；

一进程进入较高优先级队列时可能要重新调度。
