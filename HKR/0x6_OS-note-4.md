# 4. 存储管理（续）

#### （1）单一连续分区分配

内存的用户区中仅驻留一道程序，整个用户区被一个用户独占。

![image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/4.5.png)

基址寄存器:存放用户的首地址
界限寄存器：存放内存用户区的长度

#### （2）分区存储管理

将内存用户空间划分为若干个固定大小的区域，每个分区中只装入一个作业；

##### 固定分区（分区大小相等）

![image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/4.6.png)

##### 可变分区存储管理（分区大小不等）

 系统不预先划分固定区域，而是程序或作业装入内存时，根据程序或作业的实际需要动态地划分内存空间。

###### a. 可变分区的数据结构

空闲分区链：通过指针，将所有空闲分区连成一个链表；
分区表:

| **起始地址** | **大小** | **状态** |
| ------------ | -------- | -------- |
| **40KB**     | **24KB** | **Job1** |
| **84KB**     | **15KB** | **Job2** |
| **126KB**    | **21KB** | **Job3** |
| **180KB**    | **10KB** | **Job4** |

​																			(已分配分区表)



###### b.可变分区分配算法

1. 首次适应算法（First Fit，FF）

   空闲分区按照 **首地址递增** 的顺序排列

   a. 优点：优先使用低地址部分空闲分区，保留了高地址部分的大量空闲分区，有利于大程序或作业的装入。
   b. 缺点：内存的低地址区留下了许多难以利用的很小空闲分区，即内存“碎片”；算法每次都从低地址部分开始查找，这增加了查找可用空闲分区的开销。

2. 循环首次适应算法（Next Fit，NF）

   空闲分区按照 **首地址递增** 的顺序排列，每次内存分配时，从上次分配的空闲分区的下个空闲分区开始顺序查找

   a. 优点：内存的空闲分区分布较均匀，减少查找空闲分区的开销。
   b. 缺点：经多次分配后，内存缺少较大的空闲分区，以分配给较大的程序或作业。

3. 最佳适应算法（Best Fit，BF）

   空闲分区按 **从小到大** 的顺序排列

   a. 优点：较大的空闲分区被尽量的保留下来，有利于大程序或作业的分配。
   b. 缺点：容易产生内存碎片；每次分配后需要更新空闲分区表（链），增加了系统开销；分割后小的空闲分区处于分区表（链）首，增加了查找空闲分区的时间。

4. 最坏适应算法(Worst Fit，WF)

   空闲分区按 **从大到小** 的顺序排列

   a. 优点：不会产生过多的碎片，有利于中、小程序或作业，且查找效率高。
   b. 缺点：影响大程序或作业的分配。此外，每次分配后需要更新空闲分区表（链），增加了系统开销。



几种分配算法的**比较** :
··· 从搜索速度上看，FF具有最佳性能。
··· 首次适应算法具有最佳性能；空间利用方面，首次适应算法比最佳适应算法好，最坏适应算法最差。
··· 最佳适应算法找到的空闲分区是最佳的，但内存利用率不一定最优；
··· 首次适应算法尽可能利用低地址空间，保证了高地址有较大空闲分区，以分配给较大的程序或作业；
··· 最坏适应算法总是分割大的空闲分区，这有利于中、小程序或作业，但不利于较大的程序或作业。在实际系        统中，首次适应算法使用较广泛。



###### c.可变分区的回收

 作业运行结束后，系统需回收它所占用的内存空间，并将其登记在空闲分区表（链）中。



###### d.地址转换和存储保护

可变分区存储管理采用动态重定位方式装入程序或作业

![image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/4.7.png)



### 覆盖与交换

覆盖与交换是解决**大程序或作业与小内存**之间矛盾的两种存储管理技术，它们实质上是**从逻辑上对内存进行扩充**。

**1. 覆盖**：同一内存区域可以被不同的程序段重复使用

覆盖技术中可以相互覆盖的程序段称为**覆盖**，可以共享使用的内存区域称为**覆盖区**

**特点**：是打破了必须将一个作业的全部信息装入主存后才能运行的限制。



**2. 交换**：将内存中暂时不能运行的进程或暂时不使用的程序或数据换出到外存，以腾出足够的内存空间，把已具备运行条件的进程或进程所需要的程序或数据换入到内存。

**特点：**打破了一道程序一旦进入内存便一直运行到结束的限制。



**··· 相同点：**都实现了大作业在小内存上运行，从逻辑上扩充内存的容量。

**··· 不同点：**
        覆盖发生在同一进程（或程序）之内，而交换发生在进程（或程序）之间；
        覆盖只能在一个程序内部进行，而交换技术可以在任意程序间进行；
        覆盖要求给出程序的覆盖结构，对用户不透明，而交换技术对程序结构没有限制。



#### a. 分页存储管理

系统将内存空间划分为若干个大小相等的区域，称**物理块**或页框，内存的所有物理块从0开始编号，称为物理块号。每个物理块内部也从0开始编址，称为块内地址。

系统将用户程序或作业按照内存物理块的大小也划分成若干个区域，称为页面或**页**。各页面也是从0开始编号，称为逻辑页号。每个页面内部也从0开始编址，称为页内地址。

**逻辑地址**=页号×页长+页内偏移地址

**物理地址**=块号×块的大小+块内地址

**页表：**

![image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/4.8.png)

**分页存储管理的地址转换**：

![image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/4.9.png)



#### b. 分段存储管理

系统将内存空间动态地划分为若干个长度不相同的区域，称为**物理段**。每个物理段在内存中的起始地址，称为段始址。每个物理段内从“0”开始依次编址，称为段内地址。

系统根据程序的自身逻辑结构，将其逻辑地址空间划分为若干部分，每部分逻辑上均有完整意义，称为逻辑段（简称**段**）。

**段表：**

![image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/4.10.png)

**分段存储管理的地址转换：**

![image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/4.11.png)



#### 分页和分段的区别：

··· 页是信息的物理单位，分页仅是系统管理内存的方便而进行的，不是用户的需要；段是信息的逻辑单位，分段是出于用户的需要；
··· 页的大小固定的，具体由系统决定；段的大小不固定，由用户程序本身决定；
··· 分页的逻辑地址空间是一维的连续空间；分段的逻辑地址空间是二维的，段之间的逻辑地址是不连续的。



#### c.段页式存储管理

先分段，再分页

![image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/4.12.png)

**段页式存储管理的地址转换：**

![image text](https://github.com/KerenHHH/MyWeeklyShare/blob/master/pictures/4.13.png)



<table>
	<tr>
    	<td rowspan="2">功能</td>
        <td rowspan="2">单一连续分区</td>
        <td colspan="2">分区式</td>
        <td colspan="2">页式</td>
        <td rowspan="2">段式</td>
        <td rowspan="2">段页式</td>
	</tr>
    <tr>
    	<td>固定分区</td>
        <td>可变分区</td>
        <td>静态</td>
        <td>动态</td>
	</tr>
    <tr>
    	<td>适用环境</td>
        <td>单道</td>
        <td colspan="2">多道</td>
        <td colspan="2">多道</td>
        <td>多道</td>
        <td>多道</td>
	</tr>
        <tr>
    	<td>虚拟空间</td>
        <td>一维</td>
        <td colspan="2">一维</td>
        <td colspan="2">一维</td>
        <td>二维</td>
        <td>二维</td>
	</tr>
     <tr>
    	<td>重定位方式</td>
        <td>静态</td>
        <td>静态</td>
        <td>动态</td>
        <td  colspan="2">动态</td>
        <td>动态</td>
        <td>动态</td>
	</tr>
    <tr>
    	<td>分配方式</td>
        <td>静态分配连续区</td>
        <td colspan="2">静态分配连续区</td>
        <td colspan="2">静态或动态页为单位非连续</td>
        <td>动态分配段为单位非连续</td>
        <td>动态分配页为单位非连续</td>
	</tr>
    <tr>
    	<td>释放</td>
        <td>执行完成后全部释放</td>
        <td>执行完成后全部释放</td>
        <td>分区释放</td>
        <td>执行完成后释放</td>
        <td>淘汰与执行完后释放</td>
        <td>淘汰与执行完后释放</td>
        <td>淘汰与执行完后释放</td>
	</tr>
    <tr>
    	<td>保护</td>
        <td>越界保护或没有</td>
        <td colspan="2">越界保护与保护键</td>
        <td colspan="2">越界保护与控制保护</td>
        <td>同左</td>
        <td>同左</td>
	</tr>
    <tr>
    	<td>内存扩充</td>
        <td>覆盖与交换技术</td>
        <td colspan="2">同左</td>
        <td colspan="2">同左</td>
        <td>同左</td>
        <td>同左</td>
	</tr>
    <tr>
    	<td>共享</td>
        <td>不能</td>
        <td colspan="2">不能</td>
        <td colspan="2">较难</td>
        <td>方便</td>
        <td>方便</td>
	</tr>
    <tr>
    	<td>硬件支持</td>
        <td>保护用寄存器</td>
        <td>同左</td>
        <td>保护用寄存器加重定位机构</td>
        <td colspan="2">地址变换机构中断机构保护机构</td>    
        <td>段式地址变换机构，保护与中断动态连接机构</td>
        <td>同左</td>
	</tr>
</table>



### 虚拟存储管理

**时间的局部性：**如果程序中的某条指令或数据被访问后，那么它可能很快会再次被访问。产生时间局部性的典型原因是程序中存在循环操作；
**空间的局部性：**如果某个存储单元被访问，那么其附近的存储单元很快也会被访问。其典型情况是程序的顺序执行。

**特征：**

1. 离散性：指内存分配时采用离散分配方式，这是虚拟存储器的基础。没有离散性，就不能实现虚拟存储器，因为如果不采用离散分配方式，那么程序装入内存时需一次性全部装入内存的连续空间。

2. 多次性：指一道程序或作业被多次调入内存运行，即程序运行时无需将其全部装入，只需装入部分程序和数据即可运行，以后运行时需要哪一部分时再将其装入内存。

3. 对换性：指允许在程序或作业运行过程中进行换进、换出。

4. 虚拟性：指能够从逻辑上扩充内存的容量，使用户看到的内存容量远大于实际内存容量。



#### 1. 常用的虚拟存储器实现：

- 请求分页管理方式
  在分页存储管理的基础上，增加了请求调页功能、页面置换功能所形成的存储管理系统。
- 请求分段管理方式
  在分段存储管理基础上，增加了请求调段功能、分段置换功能所形成的存储管理系统。
- 请求段页式管理方式
  在段页式存储管理基础上，增加了请求调页、页面置换功能所形成的存储管理系统。



#### 页面置换算法( 请求分页管理方式 )：

页面置换是指当内存空间已装满而又要装入新的页面时，需将内存中的某个或某些页面置换到外存，以腾出空间给新的页面。

- **先进先出置换算法（First-In First-Out，FIFO）**

  

- **最佳置换算法（Optimal，OPT）**

  ​        从内存中淘汰以后再也不需要访问的页面、或者淘汰在最长时间内不再被访问的页面。

  

- **最近最久未使用置换算法（Least Recently Used，LRU）**

  ​        寄存器：每个页面使用一个寄存器表示其状态，系统每隔一段时间，将寄存器的值右移一位。若某个页面刚被访问，则其最高位置为1。系统选择页面淘汰时，总选择值最小的页面换出。
  ​        栈：使用栈顶来保存最近访问的页面，而栈底表示最长时间未访问的页面。因此，选择页面淘汰时，总是选择栈底的页面换出。

  

- **时钟置换算法（CLOCK）**

  ​        从最近一段时期内未被访问的页面中任意选择一个页面予以淘汰